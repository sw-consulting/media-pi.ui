# Copyright (c) 2025 sw.consulting
# This file is a part of Media Pi frontend application

map $http_upgrade $connection_upgrade {
  default upgrade;
  ''      close;
}

upstream cockpit_ws {
  server gateway:9090;   # Cockpit (gateway) container
}

upstream mediapi_core {
  server api:8081;       # media-pi.core (API) container
}

# Derive cockpit alias: prefer header returned by the auth subrequest
# (X-Cockpit-Alias). If the header is empty, fall back to "pi-<deviceId>".
# We use an intermediate variable set by auth_request_set, then map that
# variable to the final $cockpit_alias to avoid using `if` inside the
# `location` block which can cause unexpected behavior.
map $cockpit_alias_header $cockpit_alias {
  default $cockpit_alias_header;
  ""      "pi-$arg_device";
}

# Default server configuration

# Port 8082 behavior is generated at container start by `update-config.sh`.
# The script writes `/etc/nginx/conf.d/port-8082.conf` from the
# `PORT_8082_MODE` environment variable (debug|release). This file is
# included below so the behavior can be changed without editing this file.
include /etc/nginx/conf.d/port-8082.conf;

server {
  listen 8083 ssl default_server;
  listen [::]:8083 ssl default_server;
  http2;

  ssl_certificate /etc/nginx/certificate/s.crt;
  ssl_certificate_key /etc/nginx/certificate/s.key;
  root /var/www;
  index 200.html;
  server_name _;
  error_page 404 404.html;
  location / {
    try_files $uri $uri/ =404;
  }
}

# Virtual Host configuration for media-pi.sw.consulting

server {
  listen 8083 ssl ;
  listen [::]:8083 ssl ;
  http2;
  ssl_certificate /etc/nginx/certificate/s.crt;
  ssl_certificate_key /etc/nginx/certificate/s.key;
  root /var/www/media-pi;
  index index.html;

  server_name media-pi.sw.consulting;

  location / {
    try_files $uri /index.html =404;
  }
}

# ========== Cockpit vhost with access check ==========
server {
  listen 8083 ssl;
  http2;
  server_name cockpit.media-pi.sw.consulting;

  # TLS (re-use your existing certs in the UI container)
  ssl_certificate /etc/nginx/certificate/s.crt;
  ssl_certificate_key /etc/nginx/certificate/s.key;
  add_header Strict-Transport-Security "max-age=63072000; includeSubDomains; preload" always;

  # 1) Entry point: https://cockpit.media-pi.sw.consulting/?device=<deviceId>
  location = / {
  # Normalize/require query param - let the auth subrequest handle missing/invalid device
  # Subrequest to API to check access; API should respond:
    #  - 200 OK if allowed (optionally set X-Cockpit-Alias header)
    #  - 4xx otherwise
    auth_request /__auth;

  # Grab alias from API header into an intermediate variable; final $cockpit_alias
  # is computed via the `map` above which falls back to pi-$arg_device.
  auth_request_set $cockpit_alias_header $upstream_http_x_cockpit_alias;

  # Redirect the browser to Cockpit's remote-host URL
  return 302 /@$cockpit_alias/;
  }

  # 2) Internal auth subrequest → your API
  location = /__auth {
    internal;
    proxy_method GET;
    proxy_pass http://mediapi_core/api/cockpit/authorize?deviceId=$arg_device;

    # Forward identity (JWT / cookies) so API can decide
    proxy_set_header Authorization $http_authorization;
    proxy_set_header Cookie        $http_cookie;

    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Original-URI  $scheme://$host$request_uri;

  proxy_intercept_errors on;

  # Treat most upstream 4xx/5xx responses from the auth API as forbidden
  error_page 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 421 422 423 424 425 426 428 429 431 451 500 501 502 503 504 505 506 507 508 510 511 = @auth_forbidden;
  }

  location @auth_forbidden { return 403; }

  # 3) Everything else (including /@<alias>/… ) → Cockpit gateway (WebSocket-friendly)
  location / {
    proxy_pass http://cockpit_ws;

    proxy_set_header Host              $host;
    proxy_set_header X-Forwarded-Proto https;
    proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;

    proxy_http_version 1.1;
    proxy_set_header Upgrade           $http_upgrade;
    proxy_set_header Connection        $connection_upgrade;

    proxy_read_timeout  3600s;
    proxy_send_timeout  3600s;
  }
}
